// AMCAT Questions Data - Extracted from Question Banks
// Total: 70 unique questions (55 from Set 1 + 20 from Set 2 - 5 duplicates)

export const Difficulty = {
    EASY: "EASY",
    MEDIUM: "MEDIUM",
    HARD: "HARD",
    EXPERT: "EXPERT",
} as const;

export type DifficultyType = (typeof Difficulty)[keyof typeof Difficulty];

export interface AMCATQuestion {
    title: string;
    slug: string;
    difficulty: DifficultyType;
    statement: string;
    inputFormat: string;
    outputFormat: string;
    constraints: string;
    sampleInput: string;
    sampleOutput: string;
    timeLimit: number;
    memoryLimit: number;
    hint?: string;
    tags: string[];
    testCases: Array<{ input: string; output: string; isSample: boolean }>;
}

// ============================================
// PART A: EXPLICIT AMCAT CODING (Q1-Q10)
// ============================================

export const partAQuestions: AMCATQuestion[] = [
    {
        title: "Fountain Installation",
        slug: "fountain-installation",
        difficulty: Difficulty.MEDIUM,
        statement: `A 1D garden has positions 1..n. Fountain i covers positions from max(1, i - locations[i]) to min(n, i + locations[i]). Find the minimum number of fountains to activate to cover all positions 1..n.`,
        inputFormat: `Integer n (length of garden)\nn integers locations[1..n] (coverage radius of each fountain)`,
        outputFormat: `Single integer representing minimum fountains needed`,
        constraints: `1 <= n <= 10^4\n0 <= locations[i] <= 10^4`,
        sampleInput: `3\n1 1 1`,
        sampleOutput: `1`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "Greedy algorithm: iterate through positions and activate fountain with maximum coverage range for each uncovered position.",
        tags: ["greedy", "arrays"],
        testCases: [
            { input: "3\n1 1 1", output: "1", isSample: true },
            { input: "5\n0 0 0 0 0", output: "5", isSample: false },
            { input: "4\n1 2 1 0", output: "1", isSample: false },
            { input: "1\n0", output: "1", isSample: false },
            { input: "1\n5", output: "1", isSample: false },
            { input: "6\n0 0 0 0 0 0", output: "6", isSample: false },
            { input: "7\n3 3 3 3 3 3 3", output: "1", isSample: false },
            { input: "5\n2 0 0 0 2", output: "2", isSample: false },
            { input: "10\n0 1 0 1 0 1 0 1 0 1", output: "5", isSample: false },
            { input: "8\n1 1 1 1 1 1 1 1", output: "3", isSample: false },
            { input: "6\n5 0 0 0 0 5", output: "1", isSample: false },
            { input: "4\n0 1 1 0", output: "2", isSample: false },
        ],
    },
    {
        title: "Collecting Candies",
        slug: "collecting-candies",
        difficulty: Difficulty.MEDIUM,
        statement: `You have N boxes with c[i] candies each. You can pick any two boxes, merge them into a new empty box (cost = sum of candies), and repeat. Find the minimum total cost to end with one box containing all candies.`,
        inputFormat: `T (number of test cases)\nFor each test: N (number of boxes), then N integers representing candies per box`,
        outputFormat: `For each test case, print minimum total cost.`,
        constraints: `1 <= T <= 100\n1 <= N <= 10^5\n1 <= c[i] <= 10^2`,
        sampleInput: `1\n4\n1 2 3 4`,
        sampleOutput: `19`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "Use a min-heap (priority queue). Always merge the two smallest boxes to minimize cost.",
        tags: ["greedy", "sorting"],
        testCases: [
            { input: "1\n4\n1 2 3 4", output: "19", isSample: true },
            { input: "1\n2\n5 5", output: "10", isSample: false },
            { input: "1\n3\n1 1 1", output: "5", isSample: false },
            { input: "1\n1\n10", output: "0", isSample: false },
            { input: "1\n5\n1 1 1 1 1", output: "12", isSample: false },
            { input: "1\n3\n10 20 30", output: "90", isSample: false },
            { input: "1\n4\n5 5 5 5", output: "40", isSample: false },
            { input: "1\n6\n1 2 3 4 5 6", output: "51", isSample: false },
            { input: "2\n2\n1 2\n3\n3 3 3", output: "3\n15", isSample: false },
            { input: "1\n5\n10 10 10 10 10", output: "120", isSample: false },
            { input: "1\n3\n1 100 1", output: "104", isSample: false },
            { input: "1\n4\n2 2 2 2", output: "16", isSample: false },
        ],
    },
    {
        title: "Class Monitor",
        slug: "class-monitor",
        difficulty: Difficulty.EASY,
        statement: `Students arrive with ranks. The HOD writes a name when a student arrives with a rank strictly smaller than all previously seen ranks. Count how many times the name changes (including the first entry).`,
        inputFormat: `N (number of students)\nN integers representing ranks`,
        outputFormat: `Single integer (count of monitor changes).`,
        constraints: `1 <= N <= 10^5\n1 <= ranks[i] <= 10^4`,
        sampleInput: `6\n4 3 7 2 6 1`,
        sampleOutput: `4`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "Track the current minimum rank; increment count whenever a smaller rank arrives.",
        tags: ["arrays", "implementation"],
        testCases: [
            { input: "6\n4 3 7 2 6 1", output: "4", isSample: true },
            { input: "5\n1 2 3 4 5", output: "1", isSample: false },
            { input: "5\n5 4 3 2 1", output: "5", isSample: false },
            { input: "1\n100", output: "1", isSample: false },
            { input: "3\n1 1 1", output: "1", isSample: false },
            { input: "4\n10 5 3 1", output: "4", isSample: false },
            { input: "5\n5 5 5 5 5", output: "1", isSample: false },
            { input: "6\n100 90 80 70 60 50", output: "6", isSample: false },
            { input: "7\n1 2 3 4 3 2 1", output: "1", isSample: false },
            { input: "4\n50 50 25 25", output: "2", isSample: false },
            { input: "8\n8 7 6 5 4 3 2 1", output: "8", isSample: false },
            { input: "3\n3 2 3", output: "2", isSample: false },
        ],
    },
    {
        title: "Seating Arrangement",
        slug: "seating-arrangement",
        difficulty: Difficulty.MEDIUM,
        statement: `A binary string of length n with no two adjacent 1s follows a pattern: 1, 10, 100, 101, 1000, 1001, 1010, 10000, ... For each query, given k, print the k-th valid binary string.`,
        inputFormat: `T (number of test cases)\nT integers k`,
        outputFormat: `For each test case, the k-th valid binary string.`,
        constraints: `1 <= T <= 10\n1 <= k <= 10^5`,
        sampleInput: `3\n1\n4\n6`,
        sampleOutput: `1\n101\n1001`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "This is a Fibonacci-like problem. The count of n-bit strings follows the Fibonacci sequence. Use DP or math to find the k-th string.",
        tags: ["dynamic-programming", "math"],
        testCases: [
            { input: "3\n1\n4\n6", output: "1\n101\n1001", isSample: true },
            { input: "1\n10", output: "10010", isSample: false },
            { input: "1\n2", output: "10", isSample: false },
            { input: "1\n3", output: "100", isSample: false },
            { input: "1\n5", output: "1000", isSample: false },
            { input: "1\n7", output: "1010", isSample: false },
            { input: "1\n8", output: "10000", isSample: false },
            { input: "2\n1\n2", output: "1\n10", isSample: false },
            { input: "1\n12", output: "100100", isSample: false },
            { input: "1\n15", output: "101010", isSample: false },
            { input: "1\n20", output: "1010010", isSample: false },
        ],
    },
    {
        title: "Formatting Large Products",
        slug: "formatting-large-products",
        difficulty: Difficulty.MEDIUM,
        statement: `Given integers A and B, compute the product P = A * (A+1) * (A+2) * ... * B. Express P as D * 10^E where D has no trailing zeros. Print D and E.`,
        inputFormat: `Integer A\nInteger B`,
        outputFormat: `Two integers D and E such that P = D * 10^E.`,
        constraints: `1 <= A <= B <= 20`,
        sampleInput: `1\n5`,
        sampleOutput: `12 1`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "Compute product, count factors of 2 and 5, remove them (divide by 10^E), store remaining as D.",
        tags: ["math", "implementation"],
        testCases: [
            { input: "1\n5", output: "12 1", isSample: true },
            { input: "1\n10", output: "36288 2", isSample: false },
            { input: "1\n1", output: "1 0", isSample: false },
            { input: "2\n2", output: "2 0", isSample: false },
            { input: "1\n3", output: "6 0", isSample: false },
            { input: "5\n5", output: "5 0", isSample: false },
            { input: "1\n4", output: "24 0", isSample: false },
            { input: "2\n5", output: "12 1", isSample: false },
            { input: "5\n10", output: "3024 1", isSample: false },
            { input: "10\n15", output: "32432256 1", isSample: false },
            { input: "1\n2", output: "2 0", isSample: false },
        ],
    },
    {
        title: "Left Rotation of Array",
        slug: "left-rotation-of-array",
        difficulty: Difficulty.EASY,
        statement: `Given an array and an integer d, perform left rotation by d positions. One left rotation shifts all elements one position to the left; the first element moves to the end.`,
        inputFormat: `Integers n and d\nn integers (the array)`,
        outputFormat: `The rotated array (space-separated).`,
        constraints: `1 <= n <= 10^5\n0 <= d < n`,
        sampleInput: `5 2\n1 2 3 4 5`,
        sampleOutput: `3 4 5 1 2`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "Use array reversal method: reverse first d elements, reverse remaining, then reverse entire array.",
        tags: ["arrays", "implementation"],
        testCases: [
            { input: "5 2\n1 2 3 4 5", output: "3 4 5 1 2", isSample: true },
            { input: "4 0\n1 2 3 4", output: "1 2 3 4", isSample: false },
            { input: "3 1\n7 8 9", output: "8 9 7", isSample: false },
            { input: "1 0\n5", output: "5", isSample: false },
            { input: "6 3\n1 2 3 4 5 6", output: "4 5 6 1 2 3", isSample: false },
            { input: "5 4\n10 20 30 40 50", output: "50 10 20 30 40", isSample: false },
            { input: "7 1\n1 2 3 4 5 6 7", output: "2 3 4 5 6 7 1", isSample: false },
            { input: "4 2\n100 200 300 400", output: "300 400 100 200", isSample: false },
            { input: "3 2\n5 10 15", output: "15 5 10", isSample: false },
            { input: "8 4\n1 2 3 4 5 6 7 8", output: "5 6 7 8 1 2 3 4", isSample: false },
            { input: "2 1\n99 88", output: "88 99", isSample: false },
            { input: "6 5\n1 2 3 4 5 6", output: "6 1 2 3 4 5", isSample: false },
        ],
    },
    {
        title: "Trapezium Pattern",
        slug: "trapezium-pattern",
        difficulty: Difficulty.EASY,
        statement: `Print a trapezium-shaped pattern using * and . (dots). For given n, output follows a specific layout with 2n-1 lines.`,
        inputFormat: `Single integer n.`,
        outputFormat: `Pattern lines (typically 2n-1 lines).`,
        constraints: `1 <= n <= 10`,
        sampleInput: `3`,
        sampleOutput: `***\n.***\n..***\n.***\n***`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "For each row, calculate number of leading dots and print stars. Mirror structure for bottom half.",
        tags: ["implementation", "strings"],
        testCases: [
            { input: "3", output: "***\n.***\n..***\n.***\n***", isSample: true },
            { input: "2", output: "**\n.**\n**", isSample: false },
            { input: "1", output: "*", isSample: false },
            { input: "4", output: "****\n.****\n..****\n...****\n..****\n.****\n****", isSample: false },
            { input: "5", output: "*****\n.*****\n..*****\n...*****\n....*****\n...*****\n..*****\n.*****\n*****", isSample: false },
        ],
    },
    {
        title: "Vowel Encryption",
        slug: "vowel-encryption",
        difficulty: Difficulty.MEDIUM,
        statement: `Given a numeric string, map prime digits (2, 3, 5, 7) to vowels and non-prime digits to consonants. Choose the mapping so that the resulting encrypted string is lexicographically smallest.`,
        inputFormat: `A numeric string (digits only).`,
        outputFormat: `Encrypted string (lowercase letters).`,
        constraints: `String length up to 10^3`,
        sampleInput: `123421`,
        sampleOutput: `baecab`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "Identify distinct digits; assign prime digits to vowels (a,e,i,o,u) and non-primes to consonants (b,c,d,...) greedily to minimize result.",
        tags: ["strings", "greedy"],
        testCases: [
            { input: "123421", output: "baecab", isSample: true },
            { input: "2357", output: "aeio", isSample: false },
            { input: "0", output: "b", isSample: false },
            { input: "2", output: "a", isSample: false },
            { input: "11111", output: "bbbbb", isSample: false },
            { input: "22222", output: "aaaaa", isSample: false },
            { input: "0123456789", output: "bcadecfgah", isSample: false },
            { input: "9876543210", output: "hagfcedacb", isSample: false },
            { input: "3333", output: "aaaa", isSample: false },
            { input: "5757", output: "aeae", isSample: false },
            { input: "111222333", output: "bbbaaaeee", isSample: false },
        ],
    },
    {
        title: "Maximum of Minimums",
        slug: "maximum-of-minimums",
        difficulty: Difficulty.MEDIUM,
        statement: `Given an array and integer k, for every contiguous subarray of size k, compute its minimum. Then return the maximum among all these minima.`,
        inputFormat: `Integers k and n\nn integers (the array)`,
        outputFormat: `Single integer.`,
        constraints: `1 <= k <= n <= 10^5`,
        sampleInput: `1\n5\n1 2 3 1 2`,
        sampleOutput: `3`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "Use a deque to efficiently track minimums in sliding windows; iterate through and track max of these minimums.",
        tags: ["arrays", "binary-search"],
        testCases: [
            { input: "1\n5\n1 2 3 1 2", output: "3", isSample: true },
            { input: "3\n5\n2 1 3 4 2", output: "2", isSample: false },
            { input: "1\n1\n5", output: "5", isSample: false },
            { input: "2\n3\n1 2 3", output: "2", isSample: false },
            { input: "5\n5\n1 2 3 4 5", output: "1", isSample: false },
            { input: "2\n5\n5 4 3 2 1", output: "4", isSample: false },
            { input: "3\n6\n1 1 1 1 1 1", output: "1", isSample: false },
            { input: "4\n6\n6 5 4 3 2 1", output: "3", isSample: false },
            { input: "2\n4\n1 3 2 4", output: "3", isSample: false },
            { input: "3\n7\n7 1 6 2 5 3 4", output: "3", isSample: false },
            { input: "1\n4\n10 20 30 40", output: "40", isSample: false },
        ],
    },
    {
        title: "Queries for Count",
        slug: "queries-for-count",
        difficulty: Difficulty.MEDIUM,
        statement: `Given an array and multiple range queries [L, R], count how many array elements lie within the inclusive range for each query.`,
        inputFormat: `Integer n\nn array elements\nInteger q (number of queries)\nq lines, each with L R`,
        outputFormat: `For each query, print the count.`,
        constraints: `1 <= n <= 10^5\n1 <= q <= 10^4`,
        sampleInput: `5\n1 4 2 7 2\n3\n1 2\n2 6\n8 10`,
        sampleOutput: `3\n4\n0`,
        timeLimit: 1000,
        memoryLimit: 256,
        hint: "Sort array and use binary search (upper_bound - lower_bound) for each query.",
        tags: ["arrays", "binary-search", "sorting"],
        testCases: [
            { input: "5\n1 4 2 7 2\n3\n1 2\n2 6\n8 10", output: "3\n4\n0", isSample: true },
            { input: "3\n1 2 3\n2\n1 3\n4 5", output: "3\n0", isSample: false },
            { input: "1\n5\n1\n1 10", output: "1", isSample: false },
            { input: "4\n1 1 1 1\n2\n1 1\n0 2", output: "4\n4", isSample: false },
            { input: "5\n10 20 30 40 50\n3\n10 20\n25 35\n1 100", output: "2\n1\n5", isSample: false },
            { input: "6\n5 5 5 5 5 5\n2\n5 5\n1 4", output: "6\n0", isSample: false },
            { input: "4\n1 2 3 4\n4\n1 1\n2 2\n3 3\n4 4", output: "1\n1\n1\n1", isSample: false },
            { input: "3\n100 200 300\n2\n100 300\n150 250", output: "3\n1", isSample: false },
            { input: "5\n1 3 5 7 9\n3\n2 4\n6 8\n0 10", output: "1\n1\n5", isSample: false },
            { input: "4\n2 4 6 8\n2\n1 5\n7 9", output: "2\n1", isSample: false },
        ],
    },
];
